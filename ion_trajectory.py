import numpy as np
from scipy.interpolate import RegularGridInterpolator as rgi

def Euler(dt, x0, v0, q, m, interp):
    E = interp(x0) #remember this should be a 3D array
    F = q*E + force_ions(x0,q)  # Evaluates the force due to the capacitors
    
    a = F/m
    v = v0 + a*dt
    x = x0 + a*dt*dt
    return x,v

def force_ions(positions: np.array, charges: np.array):
    k=9*m.pow(10,9)
    force=np.zeros((len(positions), 3))
    for j in range(len(positions)):
        for i in range(len(positions)):
            if i!=j:
                v_dist=np.subtract(positions[j],positions[i])
                mod=m.dist([0,0,0],v_dist)
                dist_3=m.pow(mod,3)
                scalar=(k*charges[j]*charges[i]/dist_3)
                force[j]=force[j]+scalar*v_dist
    return force

mesh=[] # We take the meshgrid points
V=[] # We take the potential generated by our capacitors at each mesh point
[Ex, Ey, Ez] = np.gradient(-V) # The Ei may have to be swapped, i'm not sure yet

interp = rgi(grid, [Ex, Ey, Ez]) # interpolator function. It should return E at certain points (x,y,z) to be given.

#time differential and initial conditions
dt = 10e-3
num_ions=2
x0 = [[0,0,0],[0.1,0.1,0.1]] #This should be an array of 3D arrays
v0 = np.zeros((len(num_ions), 3)) #This should be an array of 3D arrays
q=np.ones((len(num_ions), 3))*1.6e-9 #ion charge
m=np.ones((len(num_ions), 3))*10e-25 #ion mass

x = x0 # We will save our trajectories here
v = v0

t = 0 # Total span of time we want to see the trajectories in

R=[]
for k in range(t/dt):
    #Euler's method for each particle
    x1=np.zeros((len(num_ions), 3))
    v1=np.zeros((len(num_ions), 3))
    for i in range(len(x0)):
        R.append(x)
        x1,v1 = Euler(dt, x, v, q, m, interp)
        x=x1
        v=v1



