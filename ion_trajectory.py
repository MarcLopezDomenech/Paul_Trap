import numpy as np
from scipy.interpolate import RegularGridInterpolator as rgi
from scipy.interpolate import interpn

def trajectory(X: np.array, Y: np.array, Z: np.array, V: np.array, tot_time:float, dt:float, init_pos:np.array, charges:np.array, mases:np.array):
    velocity=np.zeros(len(init_pos), 3)
    position=init_pos
    t=0
    E_grid=-1*np.gradient(V)
    Traj=[position]

    while t<tot_time:
        E_pos=interpn(np.transpose(np.array([X,Y,Z]).reshape(3,-1)),E_grid,position)
        F_e = charges*E_pos
        F_i=force_ions(position,charges)
        F=F_e+F_i
        a = F/mases
        velocity = velocity + a*dt
        position = position + velocity*dt

        t=t+dt
        Traj = np.vstack ((Traj, position) )

    return Traj

# def Euler(dt, x0, v0, q, m, interp):
#     E = interp(x0) #remember this should be a 3D array
#     F = q*E + force_ions(x0,q)  # Evaluates the force due to the capacitors
    
#     a = F/m
#     v = v0 + a*dt
#     x = x0 + a*dt*dt
#     return x,v

def force_ions(positions: np.array, charges: np.array):
    k=9*m.pow(10,9)
    force=np.zeros((len(positions), 3))
    for j in range(len(positions)):
        for i in range(len(positions)):
            if i!=j:
                v_dist=np.subtract(positions[j],positions[i])
                mod=m.dist([0,0,0],v_dist)
                dist_3=m.pow(mod,3)
                scalar=(k*charges[j]*charges[i]/dist_3)
                force[j]=force[j]+scalar*v_dist
    return force

# mesh=[] # We take the meshgrid points
# V=[] # We take the potential generated by our capacitors at each mesh point
# [Ex, Ey, Ez] = np.gradient(-V) # The Ei may have to be swapped, i'm not sure yet

# interp = rgi(grid, [Ex, Ey, Ez]) # interpolator function. It should return E at certain points (x,y,z) to be given.

#time differential and initial conditions
dt = 10e-3
num_ions=2
x0 = [[0,0,0],[0.1,0.1,0.1]] #This should be an array of 3D arrays
v0 = np.zeros((len(num_ions), 3)) #This should be an array of 3D arrays
q=np.ones((len(num_ions), 3))*1.6e-9 #ion charge
m=np.ones((len(num_ions), 3))*10e-25 #ion mass

R=[]
# for k in range(t/dt):
#     #Euler's method for each particle
#     x1=np.zeros((len(num_ions), 3))
#     v1=np.zeros((len(num_ions), 3))
#     for i in range(len(x0)):
#         R.append(x)
#         x1,v1 = Euler(dt, x, v, q, m, interp)
#         x=x1
#         v=v1



