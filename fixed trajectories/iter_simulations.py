import numpy as np
from scipy.interpolate import RegularGridInterpolator as rgi
import matplotlib.pyplot as plt
import time

def trajectory_freq(freq:float,interpEx, interpEy, interpEz, tot_time:float, dt:float, init_pos:np.array, init_vel:np.array, charges:np.array, mases:np.array, xmin:float, xmax:float, ymin:float, ymax:float, zmin:float, zmax:float):
    '''
    * freq: frequency of oscilation
    * interpEi: interpolator of each electric field component generated by
    scipy.interpolated.RegularGridInterpolator over a rectangular meshgrid with
    bounds xmin, xmax, ymin, ymax, zmin, zmax
    * tot_time: ellapsed time in which the trajectories will be calculated
    * dt: time step
    * init_pos: initial position np.array n x 3 (n particles)
    * charges: np.array n
    * mases: np.array n

    Retuns a 3D np.array of dimensions (number of time steps) x (number of particles) x
    x 3
    '''
    velocity=init_vel
    position=init_pos
    t=0
    Traj=[position]
    #firt iteration
    E_pos=np.array([interpEx(position), interpEy(position), interpEz(position)])
    E_pos = E_pos * np.cos(2 * np.pi * freq * t)
    E_pos = E_pos.T
    F_e = np.array([charges[i]*E_pos[i] for i in range(len(charges))])
    F_i=force_ions(position,charges)
    F=F_e+F_i
    a = np.array([F[i]/mases[i] for i in range(len(mases))])
    position = position + velocity*dt
    t += dt
    Traj = np.vstack ((Traj, [position]))
    while t<tot_time:
        E_pos=np.array([interpEx(position), interpEy(position), interpEz(position)])
        E_pos = E_pos * np.cos(2 * np.pi * freq * t)
        E_pos = E_pos.T
        F_e = np.array([charges[i]*E_pos[i] for i in range(len(charges))])
        F_i=force_ions(position,charges)
        F=F_e+F_i
        a = np.array([F[i]/mases[i] for i in range(len(mases))])
        position = a*dt**2-Traj[-2]+2*position


        t=t+dt
        Traj = np.vstack ((Traj, [position]))

        '''potser no cal fer la seguent comprovacio, si la funcio dona error perque
        una particula se'n surt disminuim tot_time'''
        for pos in position:
            if pos[0] <= xmin or pos[0] >= xmax or pos[1] <= ymin or pos[1] >= ymax or pos[2] <= zmin or pos[2] >= zmax:
                print('ValueError: One of the requested xi is out of bounds')
                return Traj, False

    return Traj, True

def force_ions(positions: np.array, charges: np.array):
    k=9e9
    force=np.zeros((len(positions), 3))
    for j in range(len(positions)):
        for i in range(len(positions)):
            if i!=j:
                v_dist=np.subtract(positions[j],positions[i])
                mod=np.linalg.norm(v_dist)
                dist_3=mod**3
                scalar=(k*charges[j]*charges[i]/dist_3)
                force[j]=force[j]+scalar*v_dist
    return force


num_ions=2
#x0 = np.array([[0.5,0.5,0.0],[0.5,-0.5,0.0], [-0.5,0.5,0.0],[-0.5,-0.5,0.0]])
#v0 = np.array([[0.5,0.5,0],[0.5,-0.5,0],[-0.5,0.5,0],[-0.5,-0.5,0]])

#Generar posicions i velocitats inicials random
#De moment, crec que millor condicions inicials simetriques
charg=np.ones(num_ions)*1.6e-19 #ion charge
m=np.ones(num_ions)*2.87347958e-25 #ytterbium ion mass
#m=np.ones(num_ions)*2.49e-24 #potassium ion mass

y = np.linspace(-1, 1, 101)
z = np.linspace(-1, 1, 101)
x = np.linspace(-1, 1, 101)
dx = 2/100
Y, X, Z = np.meshgrid(y, x, z)
V = np.load('V2.npy')
vlogpot = np.linspace(0.5, 3, 50)
vlogfreq = np.linspace(3, 4, 50)
vlogfreq1 = []
vlogpot1 = []
vlogfreq2 = []
vlogpot2 = []
for logvi in vlogpot:
    for logfreq in vlogfreq:
        freq = 10**logfreq
        vi = 10**logvi
        tot_time = 2e-4 * freq / vi
        dt = 1/(freq*20)
        V0 = V*vi
        Ex, Ey, Ez=np.gradient(-V0, dx, dx, dx)
        interpEx = rgi((x, y, z), Ex)
        interpEy = rgi((x, y, z), Ey)
        interpEz = rgi((x, y, z), Ez)
        x0 = np.random.uniform(-0.5,0.5,(num_ions,3))
        v0 = np.random.uniform(-100,100,(num_ions,3))
        print('V = %f, freq = %f:' %(vi, freq))
        start = time.time()
        Traj, trapped = trajectory_freq(freq,interpEx, interpEy, interpEz,tot_time,dt,x0,v0,charg,m,-1,1,-1,1,-1,1)
        print('Calculation took', time.time()-start, 's')
        print('Ions trapped:', trapped)
        print()
        if trapped:
            vlogfreq1.append(logfreq)
            vlogpot1.append(logvi)
        else:
            vlogfreq2.append(logfreq)
            vlogpot2.append(logvi)

fig = plt.figure()
plt.plot(vlogfreq1, vlogpot1, 'o', color = 'green')
plt.plot(vlogfreq2, vlogpot2, 'o', color = 'red')
plt.show()

np.save('vlogfreq1', vlogfreq1)
np.save('vlogfreq2', vlogfreq2)
np.save('vlogpot1', vlogpot1)
np.save('vlogpot2', vlogpot2)