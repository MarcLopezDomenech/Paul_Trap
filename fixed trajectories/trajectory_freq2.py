import numpy as np
from scipy.interpolate import RegularGridInterpolator as rgi
import matplotlib.pyplot as plt
import matplotlib
import matplotlib.animation as animation
import time
import sys

def trajectory_freq(freq:float,interpEx, interpEy, interpEz, tot_time:float, dt:float, init_pos:np.array, init_vel:np.array, charges:np.array, mases:np.array, xmin:float, xmax:float, ymin:float, ymax:float, zmin:float, zmax:float):
    '''
    * freq: frequency of oscilation
    * interpEi: interpolator of each electric field component generated by
    scipy.interpolated.RegularGridInterpolator over a rectangular meshgrid with
    bounds xmin, xmax, ymin, ymax, zmin, zmax
    * tot_time: ellapsed time in which the trajectories will be calculated
    * dt: time step
    * init_pos: initial position np.array n x 3 (n particles)
    * charges: np.array n
    * mases: np.array n

    Retuns a 3D np.array of dimensions (number of time steps) x (number of particles) x
    x 3
    '''
    velocity=init_vel
    position=init_pos
    t=0
    Traj=[position]
    #firt iteration
    E_pos=np.array([interpEx(position), interpEy(position), interpEz(position)])
    E_pos = E_pos * np.cos(2 * np.pi * freq * t)
    E_pos = E_pos.T
    F_e = np.array([charges[i]*E_pos[i] for i in range(len(charges))])
    F_i=force_ions(position,charges)
    F=F_e+F_i
    a = np.array([F[i]/mases[i] for i in range(len(mases))])
    position = position + velocity*dt
    t += dt
    Traj = np.vstack ((Traj, [position]))
    while t<tot_time:
        E_pos=np.array([interpEx(position), interpEy(position), interpEz(position)])
        E_pos = E_pos * np.cos(2 * np.pi * freq * t)
        E_pos = E_pos.T
        F_e = np.array([charges[i]*E_pos[i] for i in range(len(charges))])
        F_i=force_ions(position,charges)
        F=F_e+F_i
        a = np.array([F[i]/mases[i] for i in range(len(mases))])
        position = a*dt**2-Traj[-2]+2*position


        t=t+dt
        Traj = np.vstack ((Traj, [position]))

        '''potser no cal fer la seguent comprovacio, si la funcio dona error perque
        una particula se'n surt disminuim tot_time'''
        for pos in position:
            if pos[0] <= xmin or pos[0] >= xmax or pos[1] <= ymin or pos[1] >= ymax or pos[2] <= zmin or pos[2] >= zmax:
                print('ValueError: One of the requested xi is out of bounds')
                return Traj, False

    return Traj, True

def force_ions(positions: np.array, charges: np.array):
    k=9e9
    force=np.zeros((len(positions), 3))
    for j in range(len(positions)):
        for i in range(len(positions)):
            if i!=j:
                v_dist=np.subtract(positions[j],positions[i])
                mod=np.linalg.norm(v_dist)
                dist_3=mod**3
                scalar=(k*charges[j]*charges[i]/dist_3)
                force[j]=force[j]+scalar*v_dist
    return force


num_ions=2
#x0 = np.array([[0.5,0.5,0.0],[0.5,-0.5,0.0], [-0.5,0.5,0.0],[-0.5,-0.5,0.0]])
#v0 = np.array([[0.5,0.5,0],[0.5,-0.5,0],[-0.5,0.5,0],[-0.5,-0.5,0]])

#Generar posicions i velocitats inicials random
x0 = np.random.uniform(-0.5,0.5,(num_ions,3))
v0 = np.random.uniform(-0.5,0.5,(num_ions,3))
#De moment, crec que millor condicions inicials simetriques
charg=np.ones(num_ions)*1.6e-19 #ion charge
m=np.ones(num_ions)*2.87347958e-25 #ytterbium ion mass
#m=np.ones(num_ions)*2.49e-24 #potassium ion mass

y = np.linspace(-1, 1, 101)
z = np.linspace(-1, 1, 101)
x = np.linspace(-1, 1, 101)
dx = 2/100
Y, X, Z = np.meshgrid(y, x, z)
V = np.load('V2.npy') #canviar potencial
Ex, Ey, Ez=np.gradient(-V, dx, dx, dx)
interpEx = rgi((x, y, z), Ex)
interpEy = rgi((x, y, z), Ey)
interpEz = rgi((x, y, z), Ez)
freq = 1e4 #canviar frequencia
dt = 1/(freq*20)
tot_time = 2.5 #estava agafant 0.2s/V0
start = time.time()
Traj, trapped = trajectory_freq(freq,interpEx, interpEy, interpEz,tot_time,dt,x0,v0,charg,m,-1,1,-1,1,-1,1)
print('Calculations took', time.time()-start, 's')
print('Ion trapped:', trapped)
#Plot the trajectory
ax = plt.figure().add_subplot(projection='3d')
for i in range(len(Traj[0])):
    ax.plot(Traj[:,i,0], Traj[:,i,1], Traj[:,i,2], label='Ion ' + str(i) + ' Trajectory')
    ax.scatter(Traj[0,i,0], Traj[0,i,1], Traj[0,i,2], label='initial position '+str(i))
ax.legend()
plt.show()